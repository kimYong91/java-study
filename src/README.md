# Markdown
- 과제 : 나 자신을 소개하는 글을 마크다운 형식으로 작성
- Emoji : 활용해보기
*****************
  Kim Yong introduction
  =

### job
1. job seeker
3. artist
2. student
### age
###### 34

## email
* rladyd97@naver.com
* rladyd97@google.com

### Home image
>![아파트 이미지](https://ic.zigbang.com/vp/BigData/4928/93548e07beb069e06b23137ce853e5567d71d108.jpg?w=500&h=375&q=60&a=1)
>>[![아파트 이미지와 정보](https://ic.zigbang.com/vp/BigData/4928/93548e07beb069e06b23137ce853e5567d71d108.jpg?w=500&h=375&q=60&a=1)](https://dorojuso.kr/2650010400110460007008928/%EB%B6%80%EC%82%B0%EA%B4%91%EC%97%AD%EC%8B%9C-%EC%88%98%EC%98%81%EA%B5%AC-%EA%B4%91%EC%84%9C%EB%A1%9C-54-%EA%B4%91%EC%95%88%EB%8F%99-%EC%83%81%EC%95%84%EC%95%84%ED%8C%8C%ED%8A%B8)

### java first time (2024.02.06)
1. HelloWorld<br>
public class HelloWorld { *//클래스 선언부* <br>
    public static void main(String[] args) { *// 메소드 선언부*<br>
*// main 메소드는 진입점 entry point*<br>
        System.out.println("Hello, World // 문자열에는 주석 처리가 안됨");<br>
} *//메소드 종료*<br>
} *//클래스 종료*<br>

   
2. result<br>
'public class Statement {<br>
   public static void main(String[] args) {<br>
   /*<br>
   *실행문 끝에는 반드시 세미콜론(;)을 붙여서 실행문이 끝났음을 표시해야 한다.<br>*
   *세미콜론은 명령의 끝을 의미하기에 한줄에 여러 명령을 붙여 사용하여도 세미콜론 때문에 상관없다.*
   */ <br>
   System.out.println("Hello");<br>
        int x; *//x라는 변수를 선언*<br>
        x = 1; *//x에 1을 저장해라*<br>
        int y = 2; *//y를 선언하고 2를 저장해라*<br>
        int result = x + y; *//result를 선언하고 x와 y를 더해서 저장하라*<br>
        System.out.println(result); *//출력하라*<br>
   }<br>
}'
## Index
1. 자바 설치 및 IDE 설치와 운용
 - 프로그래밍이란?
 - 주석, 실행문
 - JDE, JRE, JVM
2. 변수
 - 변수 선언. 변수 초기화 
 - 변수 사용, 변수 사용범위
3. 타입
 - 정수 타입 : int, long
 - 실수 타입 : double
 - 논리 타입 : boolean
4. 타입 변화
 - 자동 타입 변화 : 작은범위 -> 큰 범위
 - 강제 타입 변환 : 큰 범위 -> 작은 범위 (캐스팅 연산자)
5. 연산자
 - 단항 연산자, 이항 연산자, 삼항 연산자
 - 산술 연산자, 대입 연산자, 증감 연산자 등
 - 연산자 우선순위가 존재 :()....
6. 조건문
 - if
   - if-else, if-else-if 
- swich
  - case
- return
  1. void외 다른 타입은 return 값이 필수 이다.
  2. 같은 메서드에서 다른 메서드를 멈추게 하는 효과
     - 예) 조건문일때 void 메서드 안의 코드 중간에 return을 달아 조건문을 완성할 수 있다.
  3. 보여주기 위한 값이 아닌 전달하기 위한 값이 있을때 전달하기 위한 값을 전달하기 위해 return에 담아 보낸다.
7. 반복문
 - while
 - for
 - do-while
 - break, continue
8. 배열
 - 배열 선언, 배열 초기화, 배열 길이
 - 다차원 배열
 - 향상된 for문
9. 메서드
 - 메서드 선언, 메서드 호출
 - 리턴값, 리턴 타입
 - 매개변수, 인자
 - 메서드 오버로딩
10. 클래스
 - 클래스를 선언할 떄 앞 스펠링이 대문자로 해야함
 - 객체지향 프로그래밍
 - 필드, 생성자, 메서드
 - 패키지

## 메서드 정의
  - 제어자(Modifier) : public, static
  - 리턴 타입 (Return Type) : 메서드가 실행된 뒤 반황 되는 타입
  - 메서드 이름 (Method Name) : 메서드를 호출하는데 사용됨, 기능이 드러나도록 이름을 짓는 것이 좋다.
  - 매개변수 (Parameter) : 이름 값. 메서드 내부에서 사용 가능한 변수 매개변수가 없을수도 있음
  - 메서드 본문 (Method Body) : 실행되는 코드 블록. {} 사이 위치

## 메서드의 종류
 - 매개변수가 없고 리턴 타입도 없는 메서드 정의
 - 리턴 차입이 업는 경우 void를 사용

## 메서드의 장점
1. 반복되는 코드의 중복을 줄일 수 있다.
2. 작업이 분리되어 코드의 가독성이 향상된다.
3. 코드를 다른 프로그램에서 재사용할 수 있다.
4. 기존의 기증을 확장해서 사용하는데 유용하다.
5. 메서드를 사용할 때는 내부 작업, 구현부에 대해 알 필요가 없이 사용할 수 있다.
6. 모듈화된 메서드는 개별적으로 테스트하고 디버깅할 수 있다.
7. 유지보수가 용이해진다.

## 메서드 명령 규칙
- 기본적으로 변수의 이름을 붙이는 방식과 같다. (CamelCase) 등
- 메서드의 이름에는 동사를 사용해서 시작하는 것이 좋다. 
- addNumbers : 두 숫자를 더하는 메서드 <- 명시적으로 추측 가능
- getStudentInfo : 학생의 정보를 가져오는 메서드
- setEmployeeName : 직원의 이름을 설정하는 메서드
- 일반적으로 널리 사용되지 않는 약어는 사용하지 않는 것이 좋다.
- addN, gerSi <- 무슨 동작을 하는 메서드인지 추측이 어렵다.   


## 객체지향 프로그래밍
 - 절차적 프로그래밍 (Procedural Programming)
 - 프로그램을 일련의 순선, 절차나, 함수의 집합으로 보는 방식
 - 상단에서부터 하단으로 프로그램 토드를 순서대호 실행
 - 함수(Function)/ 절차(Procedure)를 정의 하고 호출
 - 객체지향 프로그래밍(OOP - ObjectOriented Programming)
   - 객체는 데이터 (속성, 필드)와 데이터를 조작하는 기능(함수, 메서드)으로 캡슐화됨.
   - 주요 4대 특징
     - 캡슐화 : 데이터와 기능을 캡슐처럼 함께 포장
     - 상속 : 한 클래스가 다른 클래스의 특성을 상속받음
     - 다형성 : 객체타입에 따라 다른 방식으로 작동
     - 추상화 : 복잡한 실제 세계를 단순한 모델로 표현
   - 모든 사물과 개념을 속성과 기능을 가지고 있는 객체로 단순화, 추상화 시키는 것.
   - 추상화 -> 모델링 : 데이터 + 행동
   - 객체 지향 프로그래밍 방법이 가장 널리 사용되고 있다.
 
  ## 클래스
- 클래스의 구조
    1. Filed : 객체 데이터
    2. Constructor : 객체를 생성할 때 초기화를 담당
    3. Method : 객체가 수행하는 행동
- 객체를 생성하기 위한 설계도 혹은 틀, 템플릿

## 객체
객체(Object)와 인스턴스(Instance)의 차이
  - 클래스에서 나온 실체, 인스턴스는 클래스의 관계에 맞춰져 있음
  - Student는 클래스다.
  - student1은 Student의 인스턴스다
  - student1은 객체다.

## 생성자
- 특징
 1. 클래스 이름과 동일
2. 리턴 타입이 없음 (void도 사용하지 않음)
3. 오버로딩이 가능 (매개변수의 타입이나 개수에 따라 여러개 정의 가능)
- 종류
 1. 기본 생성자 : 사용자가 정의하지 않으면 컴파일러에서 자동 생성 (매개변수 없음)
2. 사용자 정의 생성자 : 매개변수를 가지고 객체 생성시 초기값을 전달
- this 키워드
  - 객체가 자기자신을 가리키는데 사용되는 키워드
  - 생성자에서 매개변수와 클래스의 필드 이름이 중복되는 경우가 있을 때
  - this키워드를 통해 둘을 구분
    - 'this.name = name'
  - this() : 다름 생성자를 호출할 때
    - 생성자 오버로딩이 있을 때 코드의 중복을 줄일 수 있음

## 패키지
- 패키지 생성 규칙 및 관례
  1. 패키지는 전세계에서 유일하게 만드는 것이 좋다. (개인으로 사용할 때는 괜찮음)
    - 일반적으로 인터넷 도메인 이름을 역순으로 사용한다.
      - 'com.google.project.pack.abc' 등
  2. 패키지 이름에는 모두 소문자만 사용한다.
  3. '.'을 사용해서 계층구조를 만든다.
  4. 예약어를 사용할 수가 없다. 'class', 'enum', 'package' 등 사용불가
  5. 숫자로 시작할 수 없다.
  
  - 'package0'
    - 'package0.fist' 하위패키지
    - 'package0,second'
  - 세 패키지는 계층 구조를 이루지만, 각각의 패키지는 서로 다른 패키지이다.

## 접근제한자 Access Modifier
1. public
   - 어떤 글래스에서도 접근 가능
   - 사용자에게 접근을 열어두고 싶은 경우
2. protected
   - 상속 관계에서 부모 클래스가 자식 클래스에게 접근 가능할 때 사용
   - 다른 패키지에 있을 경우에도
3. default
   - 접근 제한자를 명시하지 않은 경우
   - 같은 패키지 내부에서만 접근, 사용이 가능하다.
4. private
   - 해당 멤버를 선언한 클래스에서만 접근 가능
   - 사용자에세 접근을 차단하고 싶은 경우, 내부 구현을 숨기고 싶은 경우

## Getter, Setter 메소드
- 객체지향 프로그래밍에서는 일반적으로 객체의 필드값에 외부 직접 접근을 막는다. (private)
- 사용자가 개발자의 의도에 맞게 변경하거나 값을 가지고 올 수 있도록 별도의 메서드를 만든다.
- 데이터의 무결성을 유지할 수 있음.
- 캡슐화 원칙을 실현하고, 데이터를 보호할 수 있음
1. Getter : 필드의 안전한 읽기
2. Setter : 필드의 값을 안전하게 (제약조건, 무결성 유지하며) 설정